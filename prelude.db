export let  foo : Int   be 0 in

export let Fun be (Int => Int) in

export let List : (TYPE => TYPE)  be 

    \ a : TYPE ->

     @ END ? ( a , (List $ a ) )

in

export let vector be (List $ Int) in

export let add : (Int => (Int => Int)) be

    \ n1 : Int ->
    \ n2 : Int -> 
        n1 + n2
in

export let head be 

    \ a : TYPE ->
    \ lst : (List $ a) ->
        fst lst

in

export let tail be 

    \ a : TYPE ->
    \ lst : (List $ a) ->
        snd lst

in

export let fac : Fun  be 

    \  n : Int  -> 

        if n is 1 then  1
        else n * ( fac $ (n - 1)  ) 

in

export let tup be Pair 1 2 in

module Prelude
