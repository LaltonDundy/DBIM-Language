export let add be

    \ n1 : Int ->
    \ n2 : Int -> 

        n1 + n2

in

export let vector be

    \ a : TYPE -> 
    \ n : Int -> 

            | n is 0 ->     @ END
            | elsewhere ->  (a , (vector $ a $ (n - 1) ) )

in

/*

export let goodVector be

    ( 1 , ( 2 , ( @ END ) ) ) : ( vector $! Int $! 2 )

in

export let badVector be

    ( 1 , ( 2 ,  ( @ END ) ) ) : ( vector $! Int $! 3 )

in

*/

export let vectAdd be

    \ n  :  Int                    ->
    \ v1 :  ( vector $! Int $! n ) ->
    \ v2 :  ( vector $! Int $! n ) ->

    if ( n is 0 ) then @ END else (

                let front be add $ (fst v1) $ (fst v2) in

                | n is 1 -> ( front  , ( @ END ) )
                | elsewhere ->

                 (front , (vectAdd $ (n - 1 ) $ (snd v1) $ (snd v2)))

                )

in

export let vect1 be 

    ( 1 ,  ( 2 , (@ END))) : (vector $! Int $! 2) 

in

export let vect2 be 

    ( 1 , ( 2 , ( 3 , (@ END)))) : (vector $! Int $! 3) 

in

export let wrongAns be 

    vectAdd $ 2 $ vect1 $ vect2 

in

module Vect
