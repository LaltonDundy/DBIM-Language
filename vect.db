export let add be

    \ n1 : Int ->
    \ n2 : Int -> 

        n1 + n2

in

export let vector be

    \ a : TYPE -> 
    \ n : Int -> 

            | n is 0 ->     @ END
            | elsewhere ->  (a , (vector $ a $ (n - 1) ) )

in


export let goodVector be

    ( 1 , ( 2 , ( @ END ) ) ) : ( vector $! Int $! 2 )

in

/*

export let badVector be

    ( 1 , ( 2 ,  ( @ END ) ) ) : ( vector $! Int $! 3 )

in

*/


export let vectZip be

    \ a : TYPE ->
    \ b : TYPE ->
    \ c : TYPE ->
    \ binOP :  a => ( b => c ) ->
    \ n  :  Int  ->
    \ v1 :  ( vector $! a $! n ) ->
    \ v2 :  ( vector $! b $! n ) ->

    if ( n is 0 ) then @ END else (

                let front be binOP $ (fst v1) $ (fst v2) in

                | n is 1 -> ( front  , ( @ END ) )
                | elsewhere ->

                 (front , (vectZip $ a $ b $ binOP $ (n - 1 ) $ (snd v1) $ (snd v2)))

                )

in

export let vectAdd be

        vectZip $ Int $ Int $ Int $ add

in

export let vect1 be 

    ( 1 ,  ( 2 , (@ END))) : (vector $! Int $! 2) 

in

export let vect2 be 

    ( 1 , ( 2 , ( 3 , (@ END)))) : (vector $! Int $! 3) 

in

/*
export let wrongAns be 

    vectAdd $ 2 $ vect1 $ vect2

in
*/

module Vect
